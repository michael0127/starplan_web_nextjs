generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

model User {
  id                     String              @id @default(uuid()) @db.Uuid
  email                  String              @unique
  name                   String?
  userType               UserType            @default(CANDIDATE) @map("user_type")
  createdAt              DateTime            @default(now()) @map("created_at")
  updatedAt              DateTime            @updatedAt @map("updated_at")
  hasCompletedOnboarding Boolean             @default(false) @map("has_completed_onboarding")
  jobTypes               String[]            @default([]) @map("job_types")
  preferredLocation      String?             @map("preferred_location")
  remoteOpen             Boolean             @default(false) @map("remote_open")
  avatarUrl              String?             @map("avatar_url")
  profile                Json?               @map("profile")
  categories             String[]            @default([])
  categorySkills         String[]            @default([]) @map("category_skills")
  currency               String?             @default("aud")
  experienceLevel        String?             @map("experience_level")
  experienceYearsFrom    Int?                @map("experience_years_from")
  experienceYearsTo      String?             @map("experience_years_to")
  payType                String?             @map("pay_type")
  salaryExpectationFrom  String?             @map("salary_expectation_from")
  salaryExpectationTo    String?             @map("salary_expectation_to")
  workAuthByCountry      Json?               @map("work_auth_by_country")
  workAuthCountries      String[]            @default([]) @map("work_auth_countries")
  workTypes              String[]            @default([]) @map("work_types")
  lastMatchedAt          DateTime?           @map("last_matched_at")
  candidateMatches       CandidateJobMatch[] @relation("CandidateMatches")
  company                Company?
  cvs                    CV[]
  jobPostings            JobPosting[]
  
  // Organization/Team relations
  organizationMemberships  OrganizationMember[]
  invitedMembers           OrganizationMember[]   @relation("InvitedByUser")
  sentTeamInvitations      TeamInvitation[]       @relation("TeamInviter")
  acceptedTeamInvitations  TeamInvitation[]       @relation("AcceptedInvitation")
  activityLogs             OrganizationActivityLog[]

  @@map("users")
}

model Company {
  id                           String   @id @default(uuid()) @db.Uuid
  userId                       String   @unique @map("user_id") @db.Uuid
  companyName                  String   @map("company_name")
  companyLogo                  String?  @map("company_logo")
  companyCoverImage            String?  @map("company_cover_image")
  videoLink                    String?  @map("video_link")
  website                      String?
  industry                     String?
  companySize                  String?  @map("company_size")
  description                  String?
  location                     String?
  foundedYear                  Int?     @map("founded_year")
  linkedinUrl                  String?  @map("linkedin_url")
  twitterUrl                   String?  @map("twitter_url")
  // Billing information
  billingAddress               String?  @map("billing_address")
  billingEmail                 String?  @map("billing_email")
  billingEmailSameAsRegistration Boolean @default(true) @map("billing_email_same_as_registration")
  abn                          String?  @map("abn")
  createdAt                    DateTime @default(now()) @map("created_at")
  updatedAt                    DateTime @updatedAt @map("updated_at")
  user                         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Organization/Team relations
  members                      OrganizationMember[]
  teamInvitations              TeamInvitation[]
  activityLogs                 OrganizationActivityLog[]

  @@map("companies")
}

model CV {
  id            String              @id @default(uuid()) @db.Uuid
  fileUrl       String              @map("file_url")
  extractedData Json?               @map("extracted_data")
  createdAt     DateTime            @default(now()) @map("created_at")
  updatedAt     DateTime            @updatedAt @map("updated_at")
  userId        String              @map("user_id") @db.Uuid
  matches       CandidateJobMatch[]
  user          User                @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("cvs")
}

model JobPosting {
  id                         String                    @id @default(uuid()) @db.Uuid
  userId                     String                    @map("user_id") @db.Uuid
  status                     JobStatus                 @default(DRAFT)
  createdAt                  DateTime                  @default(now()) @map("created_at")
  updatedAt                  DateTime                  @updatedAt @map("updated_at")
  jobTitle                   String                    @map("job_title")
  categorySkills             String[]                  @default([]) @map("category_skills")
  isCategoryManuallySelected Boolean                   @default(false) @map("is_category_manually_selected")
  countryRegion              String                    @map("country_region")
  experienceLevel            String                    @map("experience_level")
  experienceYearsFrom        Int                       @map("experience_years_from")
  experienceYearsTo          String                    @map("experience_years_to")
  workType                   String                    @map("work_type")
  payType                    String                    @map("pay_type")
  currency                   String
  payFrom                    String                    @map("pay_from")
  payTo                      String                    @map("pay_to")
  showSalaryOnAd             Boolean                   @default(true) @map("show_salary_on_ad")
  salaryDisplayText          String?                   @map("salary_display_text")
  companyName                String                    @default("") @map("company_name")
  jobDescription             String                    @default("") @map("job_description")
  jobSummary                 String                    @default("") @map("job_summary")
  keySellingPoint1           String?                   @map("key_selling_point_1")
  keySellingPoint2           String?                   @map("key_selling_point_2")
  keySellingPoint3           String?                   @map("key_selling_point_3")
  companyLogo                String?                   @map("company_logo")
  companyCoverImage          String?                   @map("company_cover_image")
  videoLink                  String?                   @map("video_link")
  selectedCountries          String[]                  @default([]) @map("selected_countries")
  workAuthByCountry          Json?                     @map("work_auth_by_country")
  applicationDeadline        DateTime?                 @map("application_deadline")
  categories                 String[]                  @default([])
  lastMatchedAt              DateTime?                 @map("last_matched_at")
  jdExtractedData            Json?                     @map("jd_extracted_data")
  jdFileUrl                  String?                   @map("jd_file_url")
  candidateMatches           CandidateJobMatch[]
  candidateRanking           CandidateRanking?
  customScreeningQuestions   CustomScreeningQuestion[]
  purchase                   JobPostingPurchase?
  user                       User                      @relation(fields: [userId], references: [id], onDelete: Cascade)
  systemScreeningAnswers     SystemScreeningAnswer[]
  candidateInvitations       CandidateInvitation[]

  @@map("job_postings")
}

model SystemScreeningAnswer {
  id              String     @id @default(uuid()) @db.Uuid
  jobPostingId    String     @map("job_posting_id") @db.Uuid
  questionId      String     @map("question_id")
  requirement     String
  selectedAnswers String[]   @default([]) @map("selected_answers")
  createdAt       DateTime   @default(now()) @map("created_at")
  jobPosting      JobPosting @relation(fields: [jobPostingId], references: [id], onDelete: Cascade)

  @@map("system_screening_answers")
}

model CustomScreeningQuestion {
  id                   String     @id @default(uuid()) @db.Uuid
  jobPostingId         String     @map("job_posting_id") @db.Uuid
  questionText         String     @map("question_text")
  answerType           String     @map("answer_type")
  options              String[]   @default([])
  mustAnswer           Boolean    @default(false) @map("must_answer")
  idealAnswer          Json?      @map("ideal_answer")
  disqualifyIfNotIdeal Boolean    @default(false) @map("disqualify_if_not_ideal")
  requirement          String     @default("accept-any")
  createdAt            DateTime   @default(now()) @map("created_at")
  jobPosting           JobPosting @relation(fields: [jobPostingId], references: [id], onDelete: Cascade)

  @@map("custom_screening_questions")
}

model JobPostingPurchase {
  id                    String        @id @default(uuid()) @db.Uuid
  jobPostingId          String        @unique @map("job_posting_id") @db.Uuid
  userId                String        @map("user_id") @db.Uuid
  productType           ProductType   @map("product_type")
  stripeProductId       String        @map("stripe_product_id")
  stripePriceId         String        @map("stripe_price_id")
  paymentStatus         PaymentStatus @default(PENDING) @map("payment_status")
  stripeCustomerId      String?       @map("stripe_customer_id")
  stripePaymentIntentId String?       @map("stripe_payment_intent_id")
  stripeSessionId       String?       @map("stripe_session_id")
  amount                Int
  currency              String        @default("aud")
  paidAt                DateTime?     @map("paid_at")
  refundedAt            DateTime?     @map("refunded_at")
  canceledAt            DateTime?     @map("canceled_at")
  metadata              Json?
  createdAt             DateTime      @default(now()) @map("created_at")
  updatedAt             DateTime      @updatedAt @map("updated_at")
  expiresAt             DateTime?     @map("expires_at")
  jobPosting            JobPosting    @relation(fields: [jobPostingId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([paymentStatus])
  @@index([stripePaymentIntentId])
  @@index([stripeCustomerId])
  @@index([expiresAt])
  @@map("job_posting_purchases")
}

model CandidateJobMatch {
  id                  String     @id @default(uuid()) @db.Uuid
  candidateId         String     @map("candidate_id") @db.Uuid
  jobPostingId        String     @map("job_posting_id") @db.Uuid
  cvId                String?    @map("cv_id") @db.Uuid
  passedHardGate      Boolean    @default(false) @map("passed_hard_gate")
  hardGateReasons     String[]   @default([]) @map("hard_gate_reasons")
  matchDetails        Json?      @map("match_details")
  isActive            Boolean    @default(true) @map("is_active")
  candidateViewed     Boolean    @default(false) @map("candidate_viewed")
  employerViewed      Boolean    @default(false) @map("employer_viewed")
  candidateInterested Boolean    @default(false) @map("candidate_interested")
  employerInterested  Boolean    @default(false) @map("employer_interested")
  createdAt           DateTime   @default(now()) @map("created_at")
  updatedAt           DateTime   @updatedAt @map("updated_at")
  candidate           User       @relation("CandidateMatches", fields: [candidateId], references: [id], onDelete: Cascade)
  cv                  CV?        @relation(fields: [cvId], references: [id])
  jobPosting          JobPosting @relation(fields: [jobPostingId], references: [id], onDelete: Cascade)

  @@unique([candidateId, jobPostingId])
  @@index([candidateId])
  @@index([jobPostingId])
  @@index([passedHardGate])
  @@index([isActive])
  @@index([createdAt])
  @@map("candidate_job_matches")
}

model CandidateRanking {
  id                String     @id @default(uuid()) @db.Uuid
  jobPostingId      String     @unique @map("job_posting_id") @db.Uuid
  rankedCandidates  Json       @map("ranked_candidates")
  candidateHash     String     @map("candidate_hash")
  totalCandidates   Int        @map("total_candidates")
  totalComparisons  Int        @map("total_comparisons")
  totalInputTokens  Int        @default(0) @map("total_input_tokens")
  totalOutputTokens Int        @default(0) @map("total_output_tokens")
  totalTokens       Int        @default(0) @map("total_tokens")
  inputCost         Float      @default(0) @map("input_cost")
  outputCost        Float      @default(0) @map("output_cost")
  totalCost         Float      @default(0) @map("total_cost")
  createdAt         DateTime   @default(now()) @map("created_at")
  updatedAt         DateTime   @updatedAt @map("updated_at")
  jobPosting        JobPosting @relation(fields: [jobPostingId], references: [id], onDelete: Cascade)

  @@index([jobPostingId])
  @@index([candidateHash])
  @@map("candidate_rankings")
}

// Candidate invitation for screening questions
model CandidateInvitation {
  id                  String                       @id @default(uuid()) @db.Uuid
  token               String                       @unique @default(uuid())
  jobPostingId        String                       @map("job_posting_id") @db.Uuid
  candidateId         String                       @map("candidate_id") @db.Uuid
  candidateEmail      String                       @map("candidate_email")
  candidateName       String?                      @map("candidate_name")
  status              InvitationStatus             @default(PENDING)
  message             String?                      // Optional message from employer
  sentAt              DateTime                     @default(now()) @map("sent_at")
  viewedAt            DateTime?                    @map("viewed_at")
  respondedAt         DateTime?                    @map("responded_at")
  expiresAt           DateTime                     @map("expires_at")
  createdAt           DateTime                     @default(now()) @map("created_at")
  updatedAt           DateTime                     @updatedAt @map("updated_at")
  jobPosting          JobPosting                   @relation(fields: [jobPostingId], references: [id], onDelete: Cascade)
  screeningResponses  CandidateScreeningResponse[]
  
  @@unique([jobPostingId, candidateId])
  @@index([jobPostingId])
  @@index([candidateId])
  @@index([token])
  @@index([status])
  @@map("candidate_invitations")
}

// Candidate's responses to screening questions
model CandidateScreeningResponse {
  id                   String              @id @default(uuid()) @db.Uuid
  invitationId         String              @map("invitation_id") @db.Uuid
  questionType         String              @map("question_type") // 'system' or 'custom'
  questionId           String              @map("question_id") // Reference to SystemScreeningAnswer.questionId or CustomScreeningQuestion.id
  questionText         String              @map("question_text")
  answerType           String              @map("answer_type") // 'single', 'multiple', 'yes-no', 'short-text'
  answer               Json                // Can be string, string[], or boolean
  createdAt            DateTime            @default(now()) @map("created_at")
  invitation           CandidateInvitation @relation(fields: [invitationId], references: [id], onDelete: Cascade)

  @@unique([invitationId, questionType, questionId])
  @@index([invitationId])
  @@map("candidate_screening_responses")
}

enum UserType {
  CANDIDATE
  EMPLOYER
}

enum JobStatus {
  DRAFT
  PUBLISHED
  CLOSED
  ARCHIVED
}

enum WorkType {
  FULL_TIME
  PART_TIME
  CONTRACT
  INTERNSHIP
}

enum PayType {
  ANNUAL_SALARY
  HOURLY_RATE
  DAILY_RATE
  PROJECT_BASED
}

enum ExperienceLevel {
  INTERN
  JUNIOR
  MID_LEVEL
  SENIOR
  LEAD
  PRINCIPAL
}

enum ProductType {
  JUNIOR
  SENIOR
}

enum PaymentStatus {
  PENDING
  PROCESSING
  SUCCEEDED
  FAILED
  CANCELED
  REFUNDED
}

enum InvitationStatus {
  PENDING    // Invitation sent, awaiting candidate response
  VIEWED     // Candidate has viewed the invitation
  COMPLETED  // Candidate has submitted responses
  EXPIRED    // Invitation has expired
  DECLINED   // Candidate declined to respond
}

// Email record for tracking sent emails
model EmailRecord {
  id              String      @id @default(uuid()) @db.Uuid
  senderId        String      @map("sender_id") @db.Uuid
  recipientId     String?     @map("recipient_id") @db.Uuid  // Nullable for external recipients
  recipientEmail  String      @map("recipient_email")
  recipientName   String?     @map("recipient_name")
  ccEmails        String[]    @default([]) @map("cc_emails")
  subject         String
  htmlContent     String      @map("html_content")
  status          EmailStatus @default(SENT)
  resendId        String?     @map("resend_id")  // Resend email ID for tracking
  errorMessage    String?     @map("error_message")
  sentAt          DateTime    @default(now()) @map("sent_at")
  openedAt        DateTime?   @map("opened_at")
  clickedAt       DateTime?   @map("clicked_at")
  createdAt       DateTime    @default(now()) @map("created_at")

  @@index([senderId])
  @@index([recipientId])
  @@index([recipientEmail])
  @@index([status])
  @@index([sentAt])
  @@map("email_records")
}

enum EmailStatus {
  PENDING   // Email queued for sending
  SENT      // Email successfully sent
  DELIVERED // Email delivered (if tracking available)
  OPENED    // Email opened (if tracking available)
  CLICKED   // Link in email clicked (if tracking available)
  BOUNCED   // Email bounced
  FAILED    // Email failed to send
}

// ============================================
// Organization/Team Management Models
// ============================================

enum OrganizationRole {
  OWNER   // Owner - highest permission, unique per company
  ADMIN   // Admin - can manage members, invite/remove
  MEMBER  // Member - basic operation permissions
}

enum TeamInvitationStatus {
  PENDING   // Awaiting acceptance
  ACCEPTED  // Accepted
  DECLINED  // Declined
  EXPIRED   // Expired
  REVOKED   // Revoked by admin
}

// Organization member relationship table (many-to-many)
model OrganizationMember {
  id             String           @id @default(uuid()) @db.Uuid
  companyId      String           @map("company_id") @db.Uuid
  userId         String           @map("user_id") @db.Uuid
  role           OrganizationRole @default(MEMBER)
  
  // Invitation related
  invitedBy      String?          @map("invited_by") @db.Uuid
  invitedAt      DateTime         @default(now()) @map("invited_at")
  joinedAt       DateTime?        @map("joined_at")
  
  // Status
  isActive       Boolean          @default(true) @map("is_active")
  deactivatedAt  DateTime?        @map("deactivated_at")
  deactivatedBy  String?          @map("deactivated_by") @db.Uuid
  
  // Timestamps
  createdAt      DateTime         @default(now()) @map("created_at")
  updatedAt      DateTime         @updatedAt @map("updated_at")
  
  // Relations
  company        Company          @relation(fields: [companyId], references: [id], onDelete: Cascade)
  user           User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  inviter        User?            @relation("InvitedByUser", fields: [invitedBy], references: [id], onDelete: SetNull)
  
  @@unique([companyId, userId])
  @@index([companyId])
  @@index([userId])
  @@index([role])
  @@index([isActive])
  @@map("organization_members")
}

// Team invitation table
model TeamInvitation {
  id             String               @id @default(uuid()) @db.Uuid
  token          String               @unique @default(uuid())
  companyId      String               @map("company_id") @db.Uuid
  
  // Invitation info
  email          String
  role           OrganizationRole     @default(MEMBER)
  invitedBy      String?              @map("invited_by") @db.Uuid
  
  // Status
  status         TeamInvitationStatus @default(PENDING)
  
  // Personal message (optional)
  message        String?
  
  // Time
  expiresAt      DateTime             @map("expires_at")
  respondedAt    DateTime?            @map("responded_at")
  
  // Timestamps
  createdAt      DateTime             @default(now()) @map("created_at")
  updatedAt      DateTime             @updatedAt @map("updated_at")
  
  // User linked after accepting (could be new or existing user)
  acceptedUserId String?              @map("accepted_user_id") @db.Uuid
  
  // Relations
  company        Company              @relation(fields: [companyId], references: [id], onDelete: Cascade)
  inviter        User?                @relation("TeamInviter", fields: [invitedBy], references: [id], onDelete: SetNull)
  acceptedUser   User?                @relation("AcceptedInvitation", fields: [acceptedUserId], references: [id], onDelete: SetNull)
  
  @@index([companyId])
  @@index([email])
  @@index([token])
  @@index([status])
  @@index([expiresAt])
  @@map("team_invitations")
}

// Activity log table (audit trail)
model OrganizationActivityLog {
  id          String   @id @default(uuid()) @db.Uuid
  companyId   String   @map("company_id") @db.Uuid
  userId      String?  @map("user_id") @db.Uuid
  
  // Activity info
  action      String   // e.g.: member_invited, member_removed, role_changed, invitation_revoked
  targetType  String   @map("target_type")  // e.g.: member, invitation
  targetId    String   @map("target_id") @db.Uuid
  
  // Details (JSON format for before/after state)
  details     Json?
  
  // IP and device info (optional, for security audit)
  ipAddress   String?  @map("ip_address")
  userAgent   String?  @map("user_agent")
  
  createdAt   DateTime @default(now()) @map("created_at")
  
  // Relations
  company     Company  @relation(fields: [companyId], references: [id], onDelete: Cascade)
  user        User?    @relation(fields: [userId], references: [id], onDelete: SetNull)
  
  @@index([companyId])
  @@index([userId])
  @@index([action])
  @@index([createdAt])
  @@map("organization_activity_logs")
}
